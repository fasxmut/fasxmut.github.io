<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Duckcpp: dcpp::scene::ISceneCollisionManager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="duckcpp-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Duckcpp<span id="projectnumber">&#160;2.1.0</span>
   </div>
   <div id="projectbrief">Duckcpp is a high-performance c++ graphics engine.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classdcpp_1_1scene_1_1ISceneCollisionManager.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classdcpp_1_1scene_1_1ISceneCollisionManager-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">dcpp::scene::ISceneCollisionManager Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>The Scene Collision Manager provides methods for performing collision tests and picking on scene nodes.  
 <a href="classdcpp_1_1scene_1_1ISceneCollisionManager.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ISceneCollisionManager_8hpp_source.html">duckcpp/core/engine/ISceneCollisionManager.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for dcpp::scene::ISceneCollisionManager:</div>
<div class="dyncontent">
<div class="center"><img src="classdcpp_1_1scene_1_1ISceneCollisionManager__inherit__graph.png" border="0" usemap="#adcpp_1_1scene_1_1ISceneCollisionManager_inherit__map" alt="Inheritance graph"/></div>
<map name="adcpp_1_1scene_1_1ISceneCollisionManager_inherit__map" id="adcpp_1_1scene_1_1ISceneCollisionManager_inherit__map">
<area shape="rect" title="The Scene Collision Manager provides methods for performing collision tests and picking on scene node..." alt="" coords="5,79,212,119"/>
<area shape="rect" href="classdcpp_1_1IReferenceCounted.html" title="Base class of most objects of the Duckcpp Engine." alt="" coords="16,5,201,31"/>
<area shape="poly" title=" " alt="" coords="111,44,111,79,106,79,106,44"/>
</map>
</div>
<div class="dynheader">
Collaboration diagram for dcpp::scene::ISceneCollisionManager:</div>
<div class="dyncontent">
<div class="center"><img src="classdcpp_1_1scene_1_1ISceneCollisionManager__coll__graph.png" border="0" usemap="#adcpp_1_1scene_1_1ISceneCollisionManager_coll__map" alt="Collaboration graph"/></div>
<map name="adcpp_1_1scene_1_1ISceneCollisionManager_coll__map" id="adcpp_1_1scene_1_1ISceneCollisionManager_coll__map">
<area shape="rect" title="The Scene Collision Manager provides methods for performing collision tests and picking on scene node..." alt="" coords="5,79,212,119"/>
<area shape="rect" href="classdcpp_1_1IReferenceCounted.html" title="Base class of most objects of the Duckcpp Engine." alt="" coords="16,5,201,31"/>
<area shape="poly" title=" " alt="" coords="111,44,111,79,106,79,106,44"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aaddf5ee6780a93fccf560be23a643405" id="r_aaddf5ee6780a93fccf560be23a643405"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdcpp_1_1scene_1_1ISceneCollisionManager.html#aaddf5ee6780a93fccf560be23a643405">getCollisionPoint</a> (<a class="el" href="classdcpp_1_1scene_1_1SCollisionHit.html">SCollisionHit</a> &amp;hitResult, const <a class="el" href="classdcpp_1_1nub_1_1line3d.html">nub::line3d</a>&lt; <a class="el" href="namespacedcpp.html#a93cc7c2898084f21ecea75013793af08">float32_kt</a> &gt; &amp;ray, <a class="el" href="classdcpp_1_1scene_1_1ITriangleSelector.html">ITriangleSelector</a> *selector)=0</td></tr>
<tr class="memdesc:aaddf5ee6780a93fccf560be23a643405"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the nearest collision point of a line and lots of triangles, if there is one.  <br /></td></tr>
<tr class="separator:aaddf5ee6780a93fccf560be23a643405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab195e29904825448d525c1d0934b20c9" id="r_ab195e29904825448d525c1d0934b20c9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdcpp_1_1scene_1_1ISceneCollisionManager.html#ab195e29904825448d525c1d0934b20c9">getCollisionPoint</a> (const <a class="el" href="classdcpp_1_1nub_1_1line3d.html">nub::line3d</a>&lt; <a class="el" href="namespacedcpp.html#a93cc7c2898084f21ecea75013793af08">float32_kt</a> &gt; &amp;ray, <a class="el" href="classdcpp_1_1scene_1_1ITriangleSelector.html">ITriangleSelector</a> *selector, <a class="el" href="namespacedcpp_1_1nub.html#af73093b1875036b48143a19817b9f6c7">nub::vector3df</a> &amp;outCollisionPoint, <a class="el" href="namespacedcpp_1_1nub.html#a3623a4d3b19accd2cf8a22f1d49d6b30">nub::triangle3df</a> &amp;outTriangle, <a class="el" href="classdcpp_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&amp;outNode)</td></tr>
<tr class="memdesc:ab195e29904825448d525c1d0934b20c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the nearest collision point of a line and lots of triangles, if there is one.  <br /></td></tr>
<tr class="separator:ab195e29904825448d525c1d0934b20c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a596abedf3ab816911bfe6c0b362af7fa" id="r_a596abedf3ab816911bfe6c0b362af7fa"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacedcpp_1_1nub.html#af73093b1875036b48143a19817b9f6c7">nub::vector3df</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdcpp_1_1scene_1_1ISceneCollisionManager.html#a596abedf3ab816911bfe6c0b362af7fa">getCollisionResultPosition</a> (<a class="el" href="classdcpp_1_1scene_1_1ITriangleSelector.html">ITriangleSelector</a> *selector, const <a class="el" href="namespacedcpp_1_1nub.html#af73093b1875036b48143a19817b9f6c7">nub::vector3df</a> &amp;ellipsoidPosition, const <a class="el" href="namespacedcpp_1_1nub.html#af73093b1875036b48143a19817b9f6c7">nub::vector3df</a> &amp;ellipsoidRadius, const <a class="el" href="namespacedcpp_1_1nub.html#af73093b1875036b48143a19817b9f6c7">nub::vector3df</a> &amp;ellipsoidDirectionAndSpeed, <a class="el" href="namespacedcpp_1_1nub.html#a3623a4d3b19accd2cf8a22f1d49d6b30">nub::triangle3df</a> &amp;triout, <a class="el" href="namespacedcpp_1_1nub.html#af73093b1875036b48143a19817b9f6c7">nub::vector3df</a> &amp;hitPosition, bool &amp;outFalling, <a class="el" href="classdcpp_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&amp;outNode, <a class="el" href="namespacedcpp.html#a93cc7c2898084f21ecea75013793af08">float32_kt</a> slidingSpeed=0.0005f, const <a class="el" href="namespacedcpp_1_1nub.html#af73093b1875036b48143a19817b9f6c7">nub::vector3df</a> &amp;gravityDirectionAndSpeed=<a class="el" href="namespacedcpp_1_1nub.html#af73093b1875036b48143a19817b9f6c7">nub::vector3df</a>(0.0f, 0.0f, 0.0f))=0</td></tr>
<tr class="memdesc:a596abedf3ab816911bfe6c0b362af7fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collides a moving ellipsoid with a 3d world with gravity and returns the resulting new position of the ellipsoid.  <br /></td></tr>
<tr class="separator:a596abedf3ab816911bfe6c0b362af7fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a934270beb5dab7c4bd32f9461f297f" id="r_a7a934270beb5dab7c4bd32f9461f297f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdcpp_1_1nub_1_1line3d.html">nub::line3d</a>&lt; <a class="el" href="namespacedcpp.html#a93cc7c2898084f21ecea75013793af08">float32_kt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdcpp_1_1scene_1_1ISceneCollisionManager.html#a7a934270beb5dab7c4bd32f9461f297f">getRayFromScreenCoordinates</a> (const nub::position2d&lt; <a class="el" href="namespacedcpp.html#a98a7da5e8df11d4c3cfe063fd42e491d">int32_kt</a> &gt; &amp;pos, const <a class="el" href="classdcpp_1_1scene_1_1ICameraSceneNode.html">ICameraSceneNode</a> *camera=0)=0</td></tr>
<tr class="memdesc:a7a934270beb5dab7c4bd32f9461f297f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a 3d ray which would go through the 2d screen coordinates.  <br /></td></tr>
<tr class="separator:a7a934270beb5dab7c4bd32f9461f297f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e73e7935f6ee721518785d44375cad9" id="r_a0e73e7935f6ee721518785d44375cad9"><td class="memItemLeft" align="right" valign="top">virtual nub::position2d&lt; <a class="el" href="namespacedcpp.html#a98a7da5e8df11d4c3cfe063fd42e491d">int32_kt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdcpp_1_1scene_1_1ISceneCollisionManager.html#a0e73e7935f6ee721518785d44375cad9">getScreenCoordinatesFrom3DPosition</a> (const <a class="el" href="namespacedcpp_1_1nub.html#af73093b1875036b48143a19817b9f6c7">nub::vector3df</a> &amp;pos, const <a class="el" href="classdcpp_1_1scene_1_1ICameraSceneNode.html">ICameraSceneNode</a> *camera=0, bool useViewPort=false)=0</td></tr>
<tr class="memdesc:a0e73e7935f6ee721518785d44375cad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates 2d screen position from a 3d position.  <br /></td></tr>
<tr class="separator:a0e73e7935f6ee721518785d44375cad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2c6928ce215a6b1bc1e90a55543e08d" id="r_ab2c6928ce215a6b1bc1e90a55543e08d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdcpp_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdcpp_1_1scene_1_1ISceneCollisionManager.html#ab2c6928ce215a6b1bc1e90a55543e08d">getSceneNodeFromScreenCoordinatesBB</a> (const nub::position2d&lt; <a class="el" href="namespacedcpp.html#a98a7da5e8df11d4c3cfe063fd42e491d">int32_kt</a> &gt; &amp;pos, <a class="el" href="namespacedcpp.html#a98a7da5e8df11d4c3cfe063fd42e491d">int32_kt</a> idBitMask=0, bool bNoDebugObjects=false, <a class="el" href="classdcpp_1_1scene_1_1ISceneNode.html">ISceneNode</a> *root=0)=0</td></tr>
<tr class="memdesc:ab2c6928ce215a6b1bc1e90a55543e08d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the scene node, which is currently visible under the given screen coordinates, viewed from the currently active camera.  <br /></td></tr>
<tr class="separator:ab2c6928ce215a6b1bc1e90a55543e08d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed94d28ac7d43db32265133555581d6d" id="r_aed94d28ac7d43db32265133555581d6d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdcpp_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdcpp_1_1scene_1_1ISceneCollisionManager.html#aed94d28ac7d43db32265133555581d6d">getSceneNodeFromRayBB</a> (const <a class="el" href="classdcpp_1_1nub_1_1line3d.html">nub::line3d</a>&lt; <a class="el" href="namespacedcpp.html#a93cc7c2898084f21ecea75013793af08">float32_kt</a> &gt; &amp;ray, <a class="el" href="namespacedcpp.html#a98a7da5e8df11d4c3cfe063fd42e491d">int32_kt</a> idBitMask=0, bool bNoDebugObjects=false, <a class="el" href="classdcpp_1_1scene_1_1ISceneNode.html">ISceneNode</a> *root=0)=0</td></tr>
<tr class="memdesc:aed94d28ac7d43db32265133555581d6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the nearest scene node which collides with a 3d ray and whose id matches a bitmask.  <br /></td></tr>
<tr class="separator:aed94d28ac7d43db32265133555581d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada566fec0f15b003907f17711bad6d2d" id="r_ada566fec0f15b003907f17711bad6d2d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdcpp_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdcpp_1_1scene_1_1ISceneCollisionManager.html#ada566fec0f15b003907f17711bad6d2d">getSceneNodeFromCameraBB</a> (const <a class="el" href="classdcpp_1_1scene_1_1ICameraSceneNode.html">ICameraSceneNode</a> *camera, <a class="el" href="namespacedcpp.html#a98a7da5e8df11d4c3cfe063fd42e491d">int32_kt</a> idBitMask=0, bool bNoDebugObjects=false)=0</td></tr>
<tr class="memdesc:ada566fec0f15b003907f17711bad6d2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the scene node, which the given camera is looking at and whose id matches the bitmask.  <br /></td></tr>
<tr class="separator:ada566fec0f15b003907f17711bad6d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae282347d521f1fa91f20640edf52e017" id="r_ae282347d521f1fa91f20640edf52e017"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdcpp_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdcpp_1_1scene_1_1ISceneCollisionManager.html#ae282347d521f1fa91f20640edf52e017">getSceneNodeAndCollisionPointFromRay</a> (<a class="el" href="classdcpp_1_1scene_1_1SCollisionHit.html">SCollisionHit</a> &amp;hitResult, const <a class="el" href="namespacedcpp_1_1nub.html#a99a16af27234659006afc76b42e70d9f">nub::line3df</a> &amp;ray, <a class="el" href="namespacedcpp.html#a98a7da5e8df11d4c3cfe063fd42e491d">int32_kt</a> idBitMask=0, <a class="el" href="classdcpp_1_1scene_1_1ISceneNode.html">ISceneNode</a> *collisionRootNode=0, bool noDebugObjects=false)=0</td></tr>
<tr class="memdesc:ae282347d521f1fa91f20640edf52e017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a ray/box and ray/triangle collision check on a hierarchy of scene nodes.  <br /></td></tr>
<tr class="separator:ae282347d521f1fa91f20640edf52e017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac784b5c720eb50393a0e96001a25203b" id="r_ac784b5c720eb50393a0e96001a25203b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdcpp_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdcpp_1_1scene_1_1ISceneCollisionManager.html#ac784b5c720eb50393a0e96001a25203b">getSceneNodeAndCollisionPointFromRay</a> (const <a class="el" href="namespacedcpp_1_1nub.html#a99a16af27234659006afc76b42e70d9f">nub::line3df</a> &amp;ray, <a class="el" href="namespacedcpp_1_1nub.html#af73093b1875036b48143a19817b9f6c7">nub::vector3df</a> &amp;outCollisionPoint, <a class="el" href="namespacedcpp_1_1nub.html#a3623a4d3b19accd2cf8a22f1d49d6b30">nub::triangle3df</a> &amp;outTriangle, <a class="el" href="namespacedcpp.html#a98a7da5e8df11d4c3cfe063fd42e491d">int32_kt</a> idBitMask=0, <a class="el" href="classdcpp_1_1scene_1_1ISceneNode.html">ISceneNode</a> *collisionRootNode=0, bool noDebugObjects=false)</td></tr>
<tr class="memdesc:ac784b5c720eb50393a0e96001a25203b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a ray/box and ray/triangle collision check on a hierarchy of scene nodes.  <br /></td></tr>
<tr class="separator:ac784b5c720eb50393a0e96001a25203b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classdcpp_1_1IReferenceCounted"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classdcpp_1_1IReferenceCounted')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classdcpp_1_1IReferenceCounted.html">dcpp::IReferenceCounted</a></td></tr>
<tr class="memitem:a6aa4e18369165d6b993c69d15835757b inherit pub_methods_classdcpp_1_1IReferenceCounted" id="r_a6aa4e18369165d6b993c69d15835757b"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>IReferenceCounted</b> ()</td></tr>
<tr class="memdesc:a6aa4e18369165d6b993c69d15835757b inherit pub_methods_classdcpp_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:a6aa4e18369165d6b993c69d15835757b inherit pub_methods_classdcpp_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae66f8da22e58eb6a1bb98f4ed4bfab6d inherit pub_methods_classdcpp_1_1IReferenceCounted" id="r_ae66f8da22e58eb6a1bb98f4ed4bfab6d"><td class="memItemLeft" align="right" valign="top">
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~IReferenceCounted</b> ()</td></tr>
<tr class="memdesc:ae66f8da22e58eb6a1bb98f4ed4bfab6d inherit pub_methods_classdcpp_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:ae66f8da22e58eb6a1bb98f4ed4bfab6d inherit pub_methods_classdcpp_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e00c7631ceef68b855813363b6b5366 inherit pub_methods_classdcpp_1_1IReferenceCounted" id="r_a7e00c7631ceef68b855813363b6b5366"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdcpp_1_1IReferenceCounted.html#a7e00c7631ceef68b855813363b6b5366">grab</a> () const</td></tr>
<tr class="memdesc:a7e00c7631ceef68b855813363b6b5366 inherit pub_methods_classdcpp_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grabs the object. Increments the reference counter by one.  <br /></td></tr>
<tr class="separator:a7e00c7631ceef68b855813363b6b5366 inherit pub_methods_classdcpp_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a354018f03484e10dbef6f9162510f022 inherit pub_methods_classdcpp_1_1IReferenceCounted" id="r_a354018f03484e10dbef6f9162510f022"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdcpp_1_1IReferenceCounted.html#a354018f03484e10dbef6f9162510f022">drop</a> () const</td></tr>
<tr class="memdesc:a354018f03484e10dbef6f9162510f022 inherit pub_methods_classdcpp_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drops the object. Decrements the reference counter by one.  <br /></td></tr>
<tr class="separator:a354018f03484e10dbef6f9162510f022 inherit pub_methods_classdcpp_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad874b8ef2b3bd7ca2afbf03480f32c inherit pub_methods_classdcpp_1_1IReferenceCounted" id="r_a0ad874b8ef2b3bd7ca2afbf03480f32c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedcpp.html#a98a7da5e8df11d4c3cfe063fd42e491d">int32_kt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdcpp_1_1IReferenceCounted.html#a0ad874b8ef2b3bd7ca2afbf03480f32c">getReferenceCount</a> () const</td></tr>
<tr class="memdesc:a0ad874b8ef2b3bd7ca2afbf03480f32c inherit pub_methods_classdcpp_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the reference count.  <br /></td></tr>
<tr class="separator:a0ad874b8ef2b3bd7ca2afbf03480f32c inherit pub_methods_classdcpp_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabbe65c1cda09c97fd5f1d2fd2750250 inherit pub_methods_classdcpp_1_1IReferenceCounted" id="r_aabbe65c1cda09c97fd5f1d2fd2750250"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedcpp.html#a408133811e8c56ef0d89d20315d6788a">byte8_kt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdcpp_1_1IReferenceCounted.html#aabbe65c1cda09c97fd5f1d2fd2750250">getDebugName</a> () const</td></tr>
<tr class="memdesc:aabbe65c1cda09c97fd5f1d2fd2750250 inherit pub_methods_classdcpp_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the debug name of the object.  <br /></td></tr>
<tr class="separator:aabbe65c1cda09c97fd5f1d2fd2750250 inherit pub_methods_classdcpp_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classdcpp_1_1IReferenceCounted"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classdcpp_1_1IReferenceCounted')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classdcpp_1_1IReferenceCounted.html">dcpp::IReferenceCounted</a></td></tr>
<tr class="memitem:a1eb3daac6c756cb672d3cfd1df8f324e inherit pro_methods_classdcpp_1_1IReferenceCounted" id="r_a1eb3daac6c756cb672d3cfd1df8f324e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdcpp_1_1IReferenceCounted.html#a1eb3daac6c756cb672d3cfd1df8f324e">setDebugName</a> (const <a class="el" href="namespacedcpp.html#a408133811e8c56ef0d89d20315d6788a">byte8_kt</a> *newName)</td></tr>
<tr class="memdesc:a1eb3daac6c756cb672d3cfd1df8f324e inherit pro_methods_classdcpp_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the debug name of the object.  <br /></td></tr>
<tr class="separator:a1eb3daac6c756cb672d3cfd1df8f324e inherit pro_methods_classdcpp_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The Scene Collision Manager provides methods for performing collision tests and picking on scene nodes. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ab195e29904825448d525c1d0934b20c9" name="ab195e29904825448d525c1d0934b20c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab195e29904825448d525c1d0934b20c9">&#9670;&#160;</a></span>getCollisionPoint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool dcpp::scene::ISceneCollisionManager::getCollisionPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdcpp_1_1nub_1_1line3d.html">nub::line3d</a>&lt; <a class="el" href="namespacedcpp.html#a93cc7c2898084f21ecea75013793af08">float32_kt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdcpp_1_1scene_1_1ITriangleSelector.html">ITriangleSelector</a> *&#160;</td>
          <td class="paramname"><em>selector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedcpp_1_1nub.html#af73093b1875036b48143a19817b9f6c7">nub::vector3df</a> &amp;&#160;</td>
          <td class="paramname"><em>outCollisionPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedcpp_1_1nub.html#a3623a4d3b19accd2cf8a22f1d49d6b30">nub::triangle3df</a> &amp;&#160;</td>
          <td class="paramname"><em>outTriangle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdcpp_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&amp;&#160;</td>
          <td class="paramname"><em>outNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the nearest collision point of a line and lots of triangles, if there is one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ray</td><td>Line with which collisions are tested. </td></tr>
    <tr><td class="paramname">selector</td><td>TriangleSelector containing the triangles. It can be created for example using <a class="el" href="classdcpp_1_1scene_1_1ISceneManager.html#a4b398eb694e3d0409ebd65bdd679ed6c" title="Creates a simple ITriangleSelector, based on a mesh.">ISceneManager::createTriangleSelector()</a> or ISceneManager::createTriangleOctreeSelector(). </td></tr>
    <tr><td class="paramname">outCollisionPoint</td><td>If a collision is detected, this will contain the position of the nearest collision to the line-start. </td></tr>
    <tr><td class="paramname">outTriangle</td><td>If a collision is detected, this will contain the triangle with which the ray collided. </td></tr>
    <tr><td class="paramname">outNode</td><td>If a collision is detected, this will contain the scene node associated with the triangle that was hit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a collision was detected and false if not. </dd></dl>

</div>
</div>
<a id="aaddf5ee6780a93fccf560be23a643405" name="aaddf5ee6780a93fccf560be23a643405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaddf5ee6780a93fccf560be23a643405">&#9670;&#160;</a></span>getCollisionPoint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool dcpp::scene::ISceneCollisionManager::getCollisionPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdcpp_1_1scene_1_1SCollisionHit.html">SCollisionHit</a> &amp;&#160;</td>
          <td class="paramname"><em>hitResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdcpp_1_1nub_1_1line3d.html">nub::line3d</a>&lt; <a class="el" href="namespacedcpp.html#a93cc7c2898084f21ecea75013793af08">float32_kt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdcpp_1_1scene_1_1ITriangleSelector.html">ITriangleSelector</a> *&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the nearest collision point of a line and lots of triangles, if there is one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hitResult</td><td>Contains collision result when there was a collision detected. </td></tr>
    <tr><td class="paramname">ray</td><td>Line with which collisions are tested. </td></tr>
    <tr><td class="paramname">selector</td><td>TriangleSelector to be used for the collision check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a collision was detected and false if not. <br  />
 </dd></dl>

</div>
</div>
<a id="a596abedf3ab816911bfe6c0b362af7fa" name="a596abedf3ab816911bfe6c0b362af7fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a596abedf3ab816911bfe6c0b362af7fa">&#9670;&#160;</a></span>getCollisionResultPosition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacedcpp_1_1nub.html#af73093b1875036b48143a19817b9f6c7">nub::vector3df</a> dcpp::scene::ISceneCollisionManager::getCollisionResultPosition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdcpp_1_1scene_1_1ITriangleSelector.html">ITriangleSelector</a> *&#160;</td>
          <td class="paramname"><em>selector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedcpp_1_1nub.html#af73093b1875036b48143a19817b9f6c7">nub::vector3df</a> &amp;&#160;</td>
          <td class="paramname"><em>ellipsoidPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedcpp_1_1nub.html#af73093b1875036b48143a19817b9f6c7">nub::vector3df</a> &amp;&#160;</td>
          <td class="paramname"><em>ellipsoidRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedcpp_1_1nub.html#af73093b1875036b48143a19817b9f6c7">nub::vector3df</a> &amp;&#160;</td>
          <td class="paramname"><em>ellipsoidDirectionAndSpeed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedcpp_1_1nub.html#a3623a4d3b19accd2cf8a22f1d49d6b30">nub::triangle3df</a> &amp;&#160;</td>
          <td class="paramname"><em>triout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedcpp_1_1nub.html#af73093b1875036b48143a19817b9f6c7">nub::vector3df</a> &amp;&#160;</td>
          <td class="paramname"><em>hitPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>outFalling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdcpp_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&amp;&#160;</td>
          <td class="paramname"><em>outNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedcpp.html#a93cc7c2898084f21ecea75013793af08">float32_kt</a>&#160;</td>
          <td class="paramname"><em>slidingSpeed</em> = <code>0.0005f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedcpp_1_1nub.html#af73093b1875036b48143a19817b9f6c7">nub::vector3df</a> &amp;&#160;</td>
          <td class="paramname"><em>gravityDirectionAndSpeed</em> = <code><a class="el" href="namespacedcpp_1_1nub.html#af73093b1875036b48143a19817b9f6c7">nub::vector3df</a>(0.0f,&#160;0.0f,&#160;0.0f)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collides a moving ellipsoid with a 3d world with gravity and returns the resulting new position of the ellipsoid. </p>
<p>This can be used for moving a character in a 3d world: The character will slide at walls and is able to walk up stairs. The method used how to calculate the collision result position is based on the paper "Improved Collision detection and
Response" by Kasper Fauerby. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">selector</td><td>TriangleSelector containing the triangles of the world. It can be created for example using <a class="el" href="classdcpp_1_1scene_1_1ISceneManager.html#a4b398eb694e3d0409ebd65bdd679ed6c" title="Creates a simple ITriangleSelector, based on a mesh.">ISceneManager::createTriangleSelector()</a> or ISceneManager::createTriangleOctreeSelector(). </td></tr>
    <tr><td class="paramname">ellipsoidPosition</td><td>Position of the ellipsoid. </td></tr>
    <tr><td class="paramname">ellipsoidRadius</td><td>Radius of the ellipsoid. </td></tr>
    <tr><td class="paramname">ellipsoidDirectionAndSpeed</td><td>Direction and speed of the movement of the ellipsoid. </td></tr>
    <tr><td class="paramname">triout</td><td>Optional parameter where the last triangle causing a collision is stored, if there is a collision. </td></tr>
    <tr><td class="paramname">hitPosition</td><td>Return value for the position of the collision </td></tr>
    <tr><td class="paramname">outFalling</td><td>Is set to true if the ellipsoid is falling down, caused by gravity. </td></tr>
    <tr><td class="paramname">outNode</td><td>the node with which the ellipsoid collided (if any) </td></tr>
    <tr><td class="paramname">slidingSpeed</td><td>DOCUMENTATION NEEDED. </td></tr>
    <tr><td class="paramname">gravityDirectionAndSpeed</td><td>Direction and force of gravity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New position of the ellipsoid. </dd></dl>

</div>
</div>
<a id="a7a934270beb5dab7c4bd32f9461f297f" name="a7a934270beb5dab7c4bd32f9461f297f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a934270beb5dab7c4bd32f9461f297f">&#9670;&#160;</a></span>getRayFromScreenCoordinates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdcpp_1_1nub_1_1line3d.html">nub::line3d</a>&lt; <a class="el" href="namespacedcpp.html#a93cc7c2898084f21ecea75013793af08">float32_kt</a> &gt; dcpp::scene::ISceneCollisionManager::getRayFromScreenCoordinates </td>
          <td>(</td>
          <td class="paramtype">const nub::position2d&lt; <a class="el" href="namespacedcpp.html#a98a7da5e8df11d4c3cfe063fd42e491d">int32_kt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdcpp_1_1scene_1_1ICameraSceneNode.html">ICameraSceneNode</a> *&#160;</td>
          <td class="paramname"><em>camera</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a 3d ray which would go through the 2d screen coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Screen coordinates in pixels. </td></tr>
    <tr><td class="paramname">camera</td><td>Camera from which the ray starts. If null, the active camera is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Ray starting from the position of the camera and ending at a length of the far value of the camera at a position which would be behind the 2d screen coordinates. </dd></dl>

</div>
</div>
<a id="ac784b5c720eb50393a0e96001a25203b" name="ac784b5c720eb50393a0e96001a25203b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac784b5c720eb50393a0e96001a25203b">&#9670;&#160;</a></span>getSceneNodeAndCollisionPointFromRay() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdcpp_1_1scene_1_1ISceneNode.html">ISceneNode</a> * dcpp::scene::ISceneCollisionManager::getSceneNodeAndCollisionPointFromRay </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedcpp_1_1nub.html#a99a16af27234659006afc76b42e70d9f">nub::line3df</a> &amp;&#160;</td>
          <td class="paramname"><em>ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedcpp_1_1nub.html#af73093b1875036b48143a19817b9f6c7">nub::vector3df</a> &amp;&#160;</td>
          <td class="paramname"><em>outCollisionPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedcpp_1_1nub.html#a3623a4d3b19accd2cf8a22f1d49d6b30">nub::triangle3df</a> &amp;&#160;</td>
          <td class="paramname"><em>outTriangle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedcpp.html#a98a7da5e8df11d4c3cfe063fd42e491d">int32_kt</a>&#160;</td>
          <td class="paramname"><em>idBitMask</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdcpp_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&#160;</td>
          <td class="paramname"><em>collisionRootNode</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>noDebugObjects</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a ray/box and ray/triangle collision check on a hierarchy of scene nodes. </p>
<p>Works same as other getSceneNodeAndCollisionPointFromRay but returns less information. (was written before the other getSceneNodeAndCollisionPointFromRay implementation). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ray</td><td>Line with which collisions are tested. </td></tr>
    <tr><td class="paramname">outCollisionPoint</td><td>If a collision is detected, this will contain the position of the nearest collision. </td></tr>
    <tr><td class="paramname">outTriangle</td><td>If a collision is detected, this will contain the triangle with which the ray collided. </td></tr>
    <tr><td class="paramname">idBitMask</td><td>Only scene nodes with an id which matches at least one of the bits contained in this mask will be tested. However, if this parameter is 0, then all nodes are checked. </td></tr>
    <tr><td class="paramname">collisionRootNode</td><td>the scene node at which to begin checking. Only this node and its children will be checked. If you want to check the entire scene, pass 0, and the root scene node will be used (this is the default). </td></tr>
    <tr><td class="paramname">noDebugObjects</td><td>when true, debug objects are not considered viable targets. Debug objects are scene nodes with IsDebugObject() = true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the scene node containing the hit triangle nearest to ray.start. If no collision is detected, then 0 is returned. </dd></dl>

</div>
</div>
<a id="ae282347d521f1fa91f20640edf52e017" name="ae282347d521f1fa91f20640edf52e017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae282347d521f1fa91f20640edf52e017">&#9670;&#160;</a></span>getSceneNodeAndCollisionPointFromRay() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdcpp_1_1scene_1_1ISceneNode.html">ISceneNode</a> * dcpp::scene::ISceneCollisionManager::getSceneNodeAndCollisionPointFromRay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdcpp_1_1scene_1_1SCollisionHit.html">SCollisionHit</a> &amp;&#160;</td>
          <td class="paramname"><em>hitResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedcpp_1_1nub.html#a99a16af27234659006afc76b42e70d9f">nub::line3df</a> &amp;&#160;</td>
          <td class="paramname"><em>ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedcpp.html#a98a7da5e8df11d4c3cfe063fd42e491d">int32_kt</a>&#160;</td>
          <td class="paramname"><em>idBitMask</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdcpp_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&#160;</td>
          <td class="paramname"><em>collisionRootNode</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>noDebugObjects</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a ray/box and ray/triangle collision check on a hierarchy of scene nodes. </p>
<p>This checks all scene nodes under the specified one, first by ray/bounding box, and then by accurate ray/triangle collision, finding the nearest collision, and the scene node containing it. It returns the node hit, and (via output parameters) the position of the collision, and the triangle that was hit.</p>
<p>All scene nodes in the hierarchy tree under the specified node are checked. Only nodes that are visible, with an ID that matches at least one bit in the supplied bitmask, and which have a triangle selector are considered as candidates for being hit. You do not have to build a meta triangle selector; the individual triangle selectors of each candidate scene node are used automatically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ray</td><td>Line with which collisions are tested. </td></tr>
    <tr><td class="paramname">outCollisionPoint</td><td>If a collision is detected, this will contain the position of the nearest collision. </td></tr>
    <tr><td class="paramname">outTriangle</td><td>If a collision is detected, this will contain the triangle with which the ray collided. </td></tr>
    <tr><td class="paramname">idBitMask</td><td>Only scene nodes with an id which matches at least one of the bits contained in this mask will be tested. However, if this parameter is 0, then all nodes are checked. </td></tr>
    <tr><td class="paramname">collisionRootNode</td><td>the scene node at which to begin checking. Only this node and its children will be checked. If you want to check the entire scene, pass 0, and the root scene node will be used (this is the default). </td></tr>
    <tr><td class="paramname">noDebugObjects</td><td>when true, debug objects are not considered viable targets. Debug objects are scene nodes with IsDebugObject() = true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the scene node containing the hit triangle nearest to ray.start. If no collision is detected, then 0 is returned. </dd></dl>

</div>
</div>
<a id="ada566fec0f15b003907f17711bad6d2d" name="ada566fec0f15b003907f17711bad6d2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada566fec0f15b003907f17711bad6d2d">&#9670;&#160;</a></span>getSceneNodeFromCameraBB()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdcpp_1_1scene_1_1ISceneNode.html">ISceneNode</a> * dcpp::scene::ISceneCollisionManager::getSceneNodeFromCameraBB </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdcpp_1_1scene_1_1ICameraSceneNode.html">ICameraSceneNode</a> *&#160;</td>
          <td class="paramname"><em>camera</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedcpp.html#a98a7da5e8df11d4c3cfe063fd42e491d">int32_kt</a>&#160;</td>
          <td class="paramname"><em>idBitMask</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bNoDebugObjects</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the scene node, which the given camera is looking at and whose id matches the bitmask. </p>
<p>A ray is simply cast from the position of the camera to the view target position, and all scene nodes are tested against this ray. The collision tests are done using a bounding box for each scene node. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">camera</td><td>Camera from which the ray is cast. </td></tr>
    <tr><td class="paramname">idBitMask</td><td>Only scene nodes with an id which matches at least one of the bits contained in this mask will be tested. However, if this parameter is 0, then all nodes are checked. feature is disabled. Please note that the default node id of -1 will match with every bitmask != 0 </td></tr>
    <tr><td class="paramname">bNoDebugObjects</td><td>Doesn't take debug objects into account when true. These are scene nodes with IsDebugObject() = true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Scene node nearest to the camera, which collides with the ray and matches the idBitMask, if the mask is not null. If no scene node is found, 0 is returned. </dd></dl>

</div>
</div>
<a id="aed94d28ac7d43db32265133555581d6d" name="aed94d28ac7d43db32265133555581d6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed94d28ac7d43db32265133555581d6d">&#9670;&#160;</a></span>getSceneNodeFromRayBB()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdcpp_1_1scene_1_1ISceneNode.html">ISceneNode</a> * dcpp::scene::ISceneCollisionManager::getSceneNodeFromRayBB </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdcpp_1_1nub_1_1line3d.html">nub::line3d</a>&lt; <a class="el" href="namespacedcpp.html#a93cc7c2898084f21ecea75013793af08">float32_kt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedcpp.html#a98a7da5e8df11d4c3cfe063fd42e491d">int32_kt</a>&#160;</td>
          <td class="paramname"><em>idBitMask</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bNoDebugObjects</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdcpp_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&#160;</td>
          <td class="paramname"><em>root</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the nearest scene node which collides with a 3d ray and whose id matches a bitmask. </p>
<p>The collision tests are done using a bounding box for each scene node. The recursive search can be limited be specifying a scene node. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ray</td><td>Line with which collisions are tested. </td></tr>
    <tr><td class="paramname">idBitMask</td><td>Only scene nodes with an id which matches at least one of the bits contained in this mask will be tested. However, if this parameter is 0, then all nodes are checked. </td></tr>
    <tr><td class="paramname">bNoDebugObjects</td><td>Doesn't take debug objects into account when true. These are scene nodes with IsDebugObject() = true. </td></tr>
    <tr><td class="paramname">root</td><td>If different from 0, the search is limited to the children of this node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Scene node nearest to ray.start, which collides with the ray and matches the idBitMask, if the mask is not null. If no scene node is found, 0 is returned. </dd></dl>

</div>
</div>
<a id="ab2c6928ce215a6b1bc1e90a55543e08d" name="ab2c6928ce215a6b1bc1e90a55543e08d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2c6928ce215a6b1bc1e90a55543e08d">&#9670;&#160;</a></span>getSceneNodeFromScreenCoordinatesBB()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdcpp_1_1scene_1_1ISceneNode.html">ISceneNode</a> * dcpp::scene::ISceneCollisionManager::getSceneNodeFromScreenCoordinatesBB </td>
          <td>(</td>
          <td class="paramtype">const nub::position2d&lt; <a class="el" href="namespacedcpp.html#a98a7da5e8df11d4c3cfe063fd42e491d">int32_kt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedcpp.html#a98a7da5e8df11d4c3cfe063fd42e491d">int32_kt</a>&#160;</td>
          <td class="paramname"><em>idBitMask</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bNoDebugObjects</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdcpp_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&#160;</td>
          <td class="paramname"><em>root</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the scene node, which is currently visible under the given screen coordinates, viewed from the currently active camera. </p>
<p>The collision tests are done using a bounding box for each scene node. You can limit the recursive search so just all children of the specified root are tested. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Position in pixel screen coordinates, under which the returned scene node will be. </td></tr>
    <tr><td class="paramname">idBitMask</td><td>Only scene nodes with an id with bits set like in this mask will be tested. If the BitMask is 0, this feature is disabled. Please note that the default node id of -1 will match with every bitmask != 0 </td></tr>
    <tr><td class="paramname">bNoDebugObjects</td><td>Doesn't take debug objects into account when true. These are scene nodes with IsDebugObject() = true. </td></tr>
    <tr><td class="paramname">root</td><td>If different from 0, the search is limited to the children of this node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Visible scene node under screen coordinates with matching bits in its id. If there is no scene node under this position, 0 is returned. </dd></dl>

</div>
</div>
<a id="a0e73e7935f6ee721518785d44375cad9" name="a0e73e7935f6ee721518785d44375cad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e73e7935f6ee721518785d44375cad9">&#9670;&#160;</a></span>getScreenCoordinatesFrom3DPosition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual nub::position2d&lt; <a class="el" href="namespacedcpp.html#a98a7da5e8df11d4c3cfe063fd42e491d">int32_kt</a> &gt; dcpp::scene::ISceneCollisionManager::getScreenCoordinatesFrom3DPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedcpp_1_1nub.html#af73093b1875036b48143a19817b9f6c7">nub::vector3df</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdcpp_1_1scene_1_1ICameraSceneNode.html">ICameraSceneNode</a> *&#160;</td>
          <td class="paramname"><em>camera</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useViewPort</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates 2d screen position from a 3d position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>3D position in world space to be transformed into 2d. </td></tr>
    <tr><td class="paramname">camera</td><td>Camera to be used. If null, the currently active camera is used. </td></tr>
    <tr><td class="paramname">useViewPort</td><td>Calculate screen coordinates relative to the current view port. Please note that unless the driver does not take care of the view port, it is usually best to get the result in absolute screen coordinates (flag=false). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>2d screen coordinates which a object in the 3d world would have if it would be rendered to the screen. If the 3d position is behind the camera, it is set to (-1000,-1000). In most cases you can ignore this fact, because if you use this method for drawing a decorator over a 3d object, it will be clipped by the screen borders. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/duckcpp/core/engine/<a class="el" href="ISceneCollisionManager_8hpp_source.html">ISceneCollisionManager.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<hr />
<div style="text-align:center">
<p>
<a href="https://cppfx.xyz/duckcpp">Duckcpp</a>
&nbsp;&nbsp;
@<a href="https://cppfx.xyz">cppfx.xyz</a>
</p>
</div>
