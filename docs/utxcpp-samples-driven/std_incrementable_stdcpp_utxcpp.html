<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>std::incrementable - stdcpp Utxcpp</title>
<link rel="stylesheet" href="boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets Vsnapshot">
<link rel="home" href="index.html" title="Utxcpp Samples Driven">
<link rel="up" href="stdcpp_utxcpp.html" title="stdcpp Utxcpp">
<link rel="prev" href="indirectly_readable_writable_std.html" title="Indirectly Readable Writable - stdcpp Utxcpp">
<link rel="next" href="std_input_or_output_iterator_std.html" title="std::input_or_output_iterator - stdcpp Utxcpp">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="viewport" content="width=device-width">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="spirit-nav">
<a accesskey="p" href="indirectly_readable_writable_std.html"><img src="images/prev.png" alt="Prev"></a><a accesskey="u" href="stdcpp_utxcpp.html"><img src="images/up.png" alt="Up"></a><a accesskey="h" href="index.html"><img src="images/home.png" alt="Home"></a><a accesskey="n" href="std_input_or_output_iterator_std.html"><img src="images/next.png" alt="Next"></a>
</div>
<div class="article">
<div class="titlepage">
<div><div><h2 class="title">
<a name="std_incrementable_stdcpp_utxcpp"></a>std::incrementable - stdcpp Utxcpp</h2></div></div>
<hr>
</div>
<h2>
<a name="std_incrementable_stdcpp_utxcpp.h0"></a>
        <span class="phrase"><a name="std_incrementable_stdcpp_utxcpp.role_cyan_std_incrementable"></a></span><a class="link" href="std_incrementable_stdcpp_utxcpp.html#std_incrementable_stdcpp_utxcpp.role_cyan_std_incrementable"><span class="cyan">std::incrementable</span></a>
      </h2>
<p>
        <span class="bold"><strong>std::incrementable Requirement List:</strong></span>
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            std::regular
          </li>
<li class="listitem">
            std::weakly_incrementable
          </li>
<li class="listitem">
            {i++} -&gt; std::same_as&lt;I&gt;
          </li>
</ul></div>
<p>
        std::incrementable
      </p>
<p>
        std::weakly_incrementable
      </p>
<p>
        std::regular
      </p>
<p>
        std::equality_comparable
      </p>
<p>
        std::copyable
      </p>
<p>
        std::default_initializable
      </p>
<p>
        std::semiregular
      </p>
<p>
        std::movable
      </p>
<h3>
<a name="std_incrementable_stdcpp_utxcpp.h1"></a>
        <span class="phrase"><a name="std_incrementable_stdcpp_utxcpp.relationship_overview"></a></span><a class="link" href="std_incrementable_stdcpp_utxcpp.html#std_incrementable_stdcpp_utxcpp.relationship_overview">Relationship
        Overview:</a>
      </h3>
<pre class="programlisting">std::incrementable
	-&gt;
		std::weakly_incrementable
			-&gt;
				std::movable
				{++i} -&gt; std::same_as&lt;I &amp;&gt;
				i++
				difference_type
		std::regular
			-&gt;
				std::semiregular
					-&gt;
						std::copyable
						std::default_initializable
				std::equality_comparable
		{i++} -&gt; std::same_as&lt;I&gt;
</pre>
<h2>
<a name="std_incrementable_stdcpp_utxcpp.h2"></a>
        <span class="phrase"><a name="std_incrementable_stdcpp_utxcpp.role_cyan_headers"></a></span><a class="link" href="std_incrementable_stdcpp_utxcpp.html#std_incrementable_stdcpp_utxcpp.role_cyan_headers"><span class="cyan">Headers</span></a>
      </h2>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iterator</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">utxcpp</span><span class="special">/</span><span class="identifier">core</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">string</span><span class="special">&gt;</span>
</pre>
<h2>
<a name="std_incrementable_stdcpp_utxcpp.h3"></a>
        <span class="phrase"><a name="std_incrementable_stdcpp_utxcpp.role_cyan_std_movable"></a></span><a class="link" href="std_incrementable_stdcpp_utxcpp.html#std_incrementable_stdcpp_utxcpp.role_cyan_std_movable"><span class="cyan">std::movable</span></a>
      </h2>
<p>
        std::movable concept requires that T is an object type that can be moved
        (that is, it can be move constructed, move assigned, and lvalues of type
        T can be swapped).
      </p>
<p>
        Requirement List:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            std::is_object_v
          </li>
<li class="listitem">
            std::move_constructible
          </li>
<li class="listitem">
            std::assignable_from
          </li>
<li class="listitem">
            std::swappable
          </li>
</ul></div>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">u_class</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
	<span class="identifier">u_class</span><span class="special">()</span> <span class="special">=</span> <span class="keyword">default</span><span class="special">;</span>
	<span class="identifier">u_class</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">u_class</span> <span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
	<span class="identifier">u_class</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">u_class</span> <span class="special">&amp;&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
<span class="special">};</span>

<span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">movable</span><span class="special">&lt;</span><span class="identifier">utx</span><span class="special">::</span><span class="identifier">i32</span><span class="special">&gt;);</span> <span class="comment">// OK</span>
<span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">movable</span><span class="special">&lt;</span><span class="identifier">utx</span><span class="special">::</span><span class="identifier">ix32</span><span class="special">&gt;);</span> <span class="comment">// OK</span>
<span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">movable</span><span class="special">&lt;</span><span class="keyword">float</span><span class="special">&gt;);</span> <span class="comment">// OK</span>
<span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">movable</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;);</span> <span class="comment">// OK</span>
<span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">movable</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;);</span> <span class="comment">// OK</span>
<span class="keyword">static_assert</span><span class="special">(!</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">movable</span><span class="special">&lt;</span><span class="identifier">u_class</span><span class="special">&gt;);</span> <span class="comment">// u_class does not satisfy std::movable.</span>
</pre>
<h2>
<a name="std_incrementable_stdcpp_utxcpp.h4"></a>
        <span class="phrase"><a name="std_incrementable_stdcpp_utxcpp.role_cyan_std_weakly_incrementab"></a></span><a class="link" href="std_incrementable_stdcpp_utxcpp.html#std_incrementable_stdcpp_utxcpp.role_cyan_std_weakly_incrementab"><span class="cyan">std::weakly_incrementable</span></a>
      </h2>
<p>
        std::weakly_incrementable concept specifies requirements on types that can
        be incremented with the pre- and post-increment operators, but those increment
        operations are not necessarily equality-preserving, and the type itself is
        not required to be std::equality_comparable.
      </p>
<p>
        Requirement List:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            std::movable
          </li>
<li class="listitem">
            Difference Type: I i1, i2: i1-i2 satisfies std::signed_integral; or I::difference_type
            satisfies std::signed_integral.
          </li>
<li class="listitem">
            {++i} -&gt; std::same_as&lt;I &amp;&gt;
          </li>
<li class="listitem">
            i++
          </li>
</ul></div>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">fizz_t</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
	<span class="keyword">using</span> <span class="identifier">difference_type</span> <span class="special">=</span> <span class="identifier">utx</span><span class="special">::</span><span class="identifier">i16</span><span class="special">;</span>
<span class="keyword">public</span><span class="special">:</span>
	<span class="identifier">fizz_t</span> <span class="keyword">operator</span><span class="special">++(</span><span class="keyword">int</span><span class="special">)</span> <span class="comment">// i++</span>
	<span class="special">{</span>
		<span class="keyword">return</span> <span class="special">*</span><span class="keyword">this</span><span class="special">;</span>
	<span class="special">}</span>
	<span class="identifier">fizz_t</span> <span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">++()</span> <span class="comment">// ++i</span>
	<span class="special">{</span>
		<span class="keyword">return</span> <span class="special">*</span><span class="keyword">this</span><span class="special">;</span>
	<span class="special">}</span>
<span class="special">};</span>

<span class="keyword">class</span> <span class="identifier">buzz_t</span>
<span class="special">{</span>
<span class="special">};</span>

<span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">weakly_incrementable</span><span class="special">&lt;</span><span class="identifier">fizz_t</span><span class="special">&gt;);</span>	<span class="comment">// satisfy</span>
<span class="keyword">static_assert</span><span class="special">(!</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">weakly_incrementable</span><span class="special">&lt;</span><span class="identifier">buzz_t</span><span class="special">&gt;);</span> <span class="comment">// buzz_t does not satisfy std::weakly_incrementable</span>

<span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">weakly_incrementable</span><span class="special">&lt;</span><span class="identifier">utx</span><span class="special">::</span><span class="identifier">i32</span><span class="special">&gt;);</span>	<span class="comment">// satisfy</span>
<span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">weakly_incrementable</span><span class="special">&lt;</span><span class="identifier">utx</span><span class="special">::</span><span class="identifier">u32</span><span class="special">&gt;);</span>	<span class="comment">// satisfy</span>
<span class="keyword">static_assert</span><span class="special">(!</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">weakly_incrementable</span><span class="special">&lt;</span><span class="identifier">utx</span><span class="special">::</span><span class="identifier">f32</span><span class="special">&gt;);</span>	<span class="comment">// floating does not satisfy std::weakly_incrementable</span>

<span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">weakly_incrementable</span><span class="special">&lt;</span><span class="identifier">utx</span><span class="special">::</span><span class="identifier">ix32</span><span class="special">&gt;);</span>	<span class="comment">// satisfy</span>
<span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">weakly_incrementable</span><span class="special">&lt;</span><span class="identifier">utx</span><span class="special">::</span><span class="identifier">ux32</span><span class="special">&gt;);</span>	<span class="comment">// satisfy</span>
<span class="keyword">static_assert</span><span class="special">(!</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">weakly_incrementable</span><span class="special">&lt;</span><span class="identifier">utx</span><span class="special">::</span><span class="identifier">fx32</span><span class="special">&gt;);</span>	<span class="comment">// floating does not satisfy std::weakly_incrementable</span>
</pre>
<h2>
<a name="std_incrementable_stdcpp_utxcpp.h5"></a>
        <span class="phrase"><a name="std_incrementable_stdcpp_utxcpp.role_cyan_std_semiregular"></a></span><a class="link" href="std_incrementable_stdcpp_utxcpp.html#std_incrementable_stdcpp_utxcpp.role_cyan_std_semiregular"><span class="cyan">std::semiregular</span></a>
      </h2>
<p>
        The semiregular concept specifies that a type is both copyable and default
        constructible. It is satisfied by types that behave similarly to built-in
        types like int, except that they need not support comparison with ==.
      </p>
<p>
        Requirement List:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            std::copyable
          </li>
<li class="listitem">
            std::default_initializable
          </li>
</ul></div>
<pre class="programlisting"><span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">semiregular</span><span class="special">&lt;</span><span class="identifier">utx</span><span class="special">::</span><span class="identifier">i32</span><span class="special">&gt;);</span>	<span class="comment">// OK</span>
<span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">semiregular</span><span class="special">&lt;</span><span class="identifier">utx</span><span class="special">::</span><span class="identifier">ix32</span><span class="special">&gt;);</span>	<span class="comment">// OK</span>
<span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">semiregular</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;);</span>	<span class="comment">// OK</span>

<span class="keyword">class</span> <span class="identifier">a_class</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
	<span class="identifier">a_class</span><span class="special">()</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
	<span class="identifier">a_class</span><span class="special">(</span><span class="keyword">int</span><span class="special">)</span>
	<span class="special">{</span>
	<span class="special">}</span>
<span class="special">};</span>
<span class="keyword">static_assert</span><span class="special">(!</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">semiregular</span><span class="special">&lt;</span><span class="identifier">a_class</span><span class="special">&gt;);</span>	<span class="comment">// a_class is not std::default_initializable (because a_class() = delete).</span>
</pre>
<h2>
<a name="std_incrementable_stdcpp_utxcpp.h6"></a>
        <span class="phrase"><a name="std_incrementable_stdcpp_utxcpp.role_cyan_std_equality_comparabl"></a></span><a class="link" href="std_incrementable_stdcpp_utxcpp.html#std_incrementable_stdcpp_utxcpp.role_cyan_std_equality_comparabl"><span class="cyan">std::equality_comparable, std::equality_comparable_with</span></a>
      </h2>
<p>
        The concept std::equality_comparable specifies that the comparison operators
        == and != on T reflects equality: == yields true if and only if the operands
        are equal.
      </p>
<p>
        operator== must be member const
      </p>
<p>
        operator!= can be implicitly deduced.
      </p>
<pre class="programlisting"><span class="comment">// operator!= can be implicitly deduced.</span>

<span class="keyword">class</span> <span class="identifier">b_class</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
	<span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">==(</span><span class="keyword">const</span> <span class="identifier">b_class</span> <span class="special">&amp;)</span> <span class="keyword">const</span> <span class="special">{</span><span class="keyword">return</span> <span class="keyword">true</span><span class="special">;}</span>
	<span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">!=(</span><span class="keyword">const</span> <span class="identifier">b_class</span> <span class="special">&amp;)</span> <span class="keyword">const</span> <span class="special">{</span><span class="keyword">return</span> <span class="keyword">false</span><span class="special">;}</span>
<span class="special">};</span>
<span class="keyword">class</span> <span class="identifier">c_class</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
	<span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">==(</span><span class="keyword">const</span> <span class="identifier">b_class</span> <span class="special">&amp;)</span> <span class="keyword">const</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
	<span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">!=(</span><span class="keyword">const</span> <span class="identifier">b_class</span> <span class="special">&amp;)</span> <span class="keyword">const</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
<span class="special">};</span>
<span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">equality_comparable</span><span class="special">&lt;</span><span class="identifier">b_class</span><span class="special">&gt;);</span>	<span class="comment">// OK</span>
<span class="keyword">static_assert</span><span class="special">(!</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">equality_comparable</span><span class="special">&lt;</span><span class="identifier">c_class</span><span class="special">&gt;);</span>	<span class="comment">// c_class is not std::equality_comparable</span>
</pre>
<h2>
<a name="std_incrementable_stdcpp_utxcpp.h7"></a>
        <span class="phrase"><a name="std_incrementable_stdcpp_utxcpp.role_cyan_std_regular"></a></span><a class="link" href="std_incrementable_stdcpp_utxcpp.html#std_incrementable_stdcpp_utxcpp.role_cyan_std_regular"><span class="cyan">std::regular</span></a>
      </h2>
<p>
        The regular concept specifies that a type is regular, that is, it is copyable,
        default constructible, and equality comparable. It is satisfied by types
        that behave similarly to built-in types like int, and that are comparable
        with ==.
      </p>
<p>
        Requirement List:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            std::semiregular
          </li>
<li class="listitem">
            std::equality_comparable
          </li>
</ul></div>
<pre class="programlisting"><span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">regular</span><span class="special">&lt;</span><span class="identifier">b_class</span><span class="special">&gt;);</span>
<span class="keyword">static_assert</span><span class="special">(!</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">regular</span><span class="special">&lt;</span><span class="identifier">c_class</span><span class="special">&gt;);</span>
<span class="keyword">static_assert</span><span class="special">(!</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">regular</span><span class="special">&lt;</span><span class="identifier">a_class</span><span class="special">&gt;);</span>
</pre>
<h2>
<a name="std_incrementable_stdcpp_utxcpp.h8"></a>
        <span class="phrase"><a name="std_incrementable_stdcpp_utxcpp.role_cyan_std_incrementable0"></a></span><a class="link" href="std_incrementable_stdcpp_utxcpp.html#std_incrementable_stdcpp_utxcpp.role_cyan_std_incrementable0"><span class="cyan">std::incrementable</span></a>
      </h2>
<p>
        std::incrementable concept specifies requirements on types that can be incremented
        with the pre- and post-increment operators, whose increment operations are
        equality-preserving, and the type is std::equality_comparable.
      </p>
<p>
        Requirement List:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            std::regular
          </li>
<li class="listitem">
            std::weakly_incrementable
          </li>
<li class="listitem">
            {i++} -&gt; std::same_as&lt;I&gt;
          </li>
</ul></div>
<pre class="programlisting"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span>

<span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">incrementable</span><span class="special">&lt;</span><span class="identifier">utx</span><span class="special">::</span><span class="identifier">ux64</span><span class="special">&gt;);</span>	<span class="comment">// OK</span>
<span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">incrementable</span><span class="special">&lt;</span><span class="identifier">utx</span><span class="special">::</span><span class="identifier">ix64</span><span class="special">&gt;);</span>	<span class="comment">// OK</span>

<span class="comment">////////////////////////////////////////////////////////////////////////////////</span>

<span class="keyword">class</span> <span class="identifier">d_class</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
	<span class="keyword">using</span> <span class="identifier">difference_type</span> <span class="special">=</span> <span class="identifier">utx</span><span class="special">::</span><span class="identifier">i64</span><span class="special">;</span>
<span class="keyword">public</span><span class="special">:</span>
	<span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">==(</span><span class="keyword">const</span> <span class="identifier">d_class</span> <span class="special">&amp;)</span> <span class="keyword">const</span> <span class="special">{</span><span class="keyword">return</span> <span class="keyword">true</span><span class="special">;}</span>
	<span class="identifier">d_class</span> <span class="keyword">operator</span><span class="special">++(</span><span class="keyword">int</span><span class="special">)</span> <span class="special">{</span><span class="keyword">return</span> <span class="special">*</span><span class="keyword">this</span><span class="special">;}</span>
	<span class="identifier">d_class</span> <span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">++()</span> <span class="special">{</span><span class="keyword">return</span> <span class="special">*</span><span class="keyword">this</span><span class="special">;}</span>
<span class="special">};</span>

<span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">incrementable</span><span class="special">&lt;</span><span class="identifier">d_class</span><span class="special">&gt;);</span>	<span class="comment">// OK</span>

<span class="comment">////////////////////////////////////////////////////////////////////////////////</span>

<span class="keyword">class</span> <span class="identifier">e_class</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
	<span class="keyword">using</span> <span class="identifier">difference_type</span> <span class="special">=</span> <span class="identifier">utx</span><span class="special">::</span><span class="identifier">i64</span><span class="special">;</span>
<span class="keyword">public</span><span class="special">:</span>
	<span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">==(</span><span class="keyword">const</span> <span class="identifier">e_class</span> <span class="special">&amp;)</span> <span class="keyword">const</span> <span class="special">{</span><span class="keyword">return</span> <span class="keyword">true</span><span class="special">;}</span>
	<span class="comment">// operator!= can be implicitly deduced.</span>

	<span class="identifier">e_class</span> <span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">++(</span><span class="keyword">int</span><span class="special">)</span> <span class="special">{</span><span class="keyword">return</span> <span class="special">*</span><span class="keyword">this</span><span class="special">;}</span>
	<span class="identifier">e_class</span> <span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">++()</span> <span class="special">{</span><span class="keyword">return</span> <span class="special">*</span><span class="keyword">this</span><span class="special">;}</span>
<span class="special">};</span>

<span class="keyword">static_assert</span><span class="special">(!</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">incrementable</span><span class="special">&lt;</span><span class="identifier">e_class</span><span class="special">&gt;);</span>	<span class="comment">// e_class does not satisfy std::incrementable.</span>
<span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">weakly_incrementable</span><span class="special">&lt;</span><span class="identifier">e_class</span><span class="special">&gt;);</span>	<span class="comment">// but e_class satisfies std::incrementable.</span>
</pre>
<h2>
<a name="std_incrementable_stdcpp_utxcpp.h9"></a>
        <span class="phrase"><a name="std_incrementable_stdcpp_utxcpp.role_cyan_main"></a></span><a class="link" href="std_incrementable_stdcpp_utxcpp.html#std_incrementable_stdcpp_utxcpp.role_cyan_main"><span class="cyan">main</span></a>
      </h2>
<pre class="programlisting"><span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
<span class="special">}</span>
</pre>
<h2>
<a name="std_incrementable_stdcpp_utxcpp.h10"></a>
        <span class="phrase"><a name="std_incrementable_stdcpp_utxcpp.role_cyan_see_also"></a></span><a class="link" href="std_incrementable_stdcpp_utxcpp.html#std_incrementable_stdcpp_utxcpp.role_cyan_see_also"><span class="cyan">See Also</span></a>
      </h2>
<p>
        <a href="https://en.cppreference.com/w/cpp/iterator" target="_top">cppreference iterator
        library</a>
      </p>
<p>
        <a href="https://cppfx.xyz/utxcpp" target="_top">utxcpp</a>
      </p>
<p>
        <a href="https://cppfx.xyz/utxcpp/utx_ix32.html" target="_top">utx::ix32</a>
      </p>
<p>
        <a href="https://cppfx.xyz/utxcpp/utx_ux64.html" target="_top">utx::ux64</a>
      </p>
<p>
        <a href="https://cppfx.xyz/utxcpp/utx_ix64.html" target="_top">utx::ix64</a>
      </p>
<p>
        <a href="https://cppfx.xyz/utxcpp/utx_fx64.html" target="_top">utx::fx64</a>
      </p>
</div>
<div class="copyright-footer">Copyright © 2022, 2023 Fas Xmut<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="indirectly_readable_writable_std.html"><img src="images/prev.png" alt="Prev"></a><a accesskey="u" href="stdcpp_utxcpp.html"><img src="images/up.png" alt="Up"></a><a accesskey="h" href="index.html"><img src="images/home.png" alt="Home"></a><a accesskey="n" href="std_input_or_output_iterator_std.html"><img src="images/next.png" alt="Next"></a>
</div>
</body>
</html>
